{"ast":null,"code":"var _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar url = require('url');\n\nvar EventEmitter = require('events').EventEmitter;\n/**\n * Log bridge, which is an [EventEmitter](http://nodejs.org/api/events.html#events_class_events_eventemitter)\n * that sends events to one or more outputs/loggers. Setup these loggers by\n * specifying their config as the first argument, or by passing it to addOutput().\n *\n * @class Log\n * @uses Loggers.Stdio\n * @constructor\n * @param {object} config\n * @param {string|Object|ArrayOfStrings|ArrayOfObjects} config.log - Either the level\n *  to setup a single logger, a full config object for a logger, or an array of\n *  config objects to use for creating log outputs.\n * @param {string|array} config.log.level|config.log.levels - One or more keys in Log.levels (error, warning, etc.)\n * @param {string} config.log.type - The name of the logger to use for this output\n */\n\n\nfunction Log(config) {\n  config = config || {};\n  if (!config.log) return;\n  var i;\n  var outputs;\n\n  if (utils.isArrayOfStrings(config.log)) {\n    outputs = [{\n      levels: config.log\n    }];\n  } else {\n    outputs = utils.createArray(config.log, function (val) {\n      if (_.isPlainObject(val)) {\n        return val;\n      }\n\n      if (typeof val === 'string') {\n        return {\n          level: val\n        };\n      }\n    });\n  }\n\n  if (!outputs) {\n    throw new TypeError('Invalid logging output config. Expected either a log level, array of log levels, ' + 'a logger config object, or an array of logger config objects.');\n  }\n\n  for (i = 0; i < outputs.length; i++) {\n    this.addOutput(outputs[i]);\n  }\n}\n\nutils.inherits(Log, EventEmitter);\nLog.loggers = require('./loggers');\n\nLog.prototype.close = function () {\n  this.emit('closing');\n\n  if (this.listenerCount()) {\n    console.error('Something is still listening for log events, but the logger is closing.'); // eslint-disable-line no-console\n\n    this.clearAllListeners();\n  }\n};\n\nif (EventEmitter.prototype.listenerCount) {\n  // If the event emitter implements it's own listenerCount method\n  // we don't need to (newer nodes do this).\n  Log.prototype.listenerCount = EventEmitter.prototype.listenerCount;\n} else if (EventEmitter.listenerCount) {\n  // some versions of node expose EventEmitter::listenerCount\n  // which is more efficient the getting all listeners of a\n  // specific type\n  Log.prototype.listenerCount = function (event) {\n    return EventEmitter.listenerCount(this, event);\n  };\n} else {\n  // all other versions of node expose a #listeners() method, which returns\n  // and array we have to count\n  Log.prototype.listenerCount = function (event) {\n    return this.listeners(event).length;\n  };\n}\n/**\n * Levels observed by the loggers, ordered by rank\n *\n * @property levels\n * @type Array\n * @static\n */\n\n\nLog.levels = [\n/**\n * Event fired for error level log entries\n * @event error\n * @param {Error} error - The error object to log\n */\n'error',\n/**\n * Event fired for \"warning\" level log entries, which usually represent things\n * like correctly formatted error responses from ES (400, ...) and recoverable\n * errors (one node unresponsive)\n *\n * @event warning\n * @param {String} message - A message to be logged\n */\n'warning',\n/**\n * Event fired for \"info\" level log entries, which usually describe what a\n * client is doing (sniffing etc)\n *\n * @event info\n * @param {String} message - A message to be logged\n */\n'info',\n/**\n * Event fired for \"debug\" level log entries, which will describe requests sent,\n * including their url (no data, response codes, or exec times)\n *\n * @event debug\n * @param {String} message - A message to be logged\n */\n'debug',\n/**\n * Event fired for \"trace\" level log entries, which provide detailed information\n * about each request made from a client, including reponse codes, execution times,\n * and a full curl command that can be copied and pasted into a terminal\n *\n * @event trace\n * @param {String} method method, , body, responseStatus, responseBody\n * @param {String} url - The url the request was made to\n * @param {String} body - The body of the request\n * @param {Integer} responseStatus - The status code returned from the response\n * @param {String} responseBody - The body of the response\n */\n'trace'];\n/**\n * Converts a log config value (string or array) to an array of level names which\n * it represents\n *\n * @method parseLevels\n * @static\n * @private\n * @param  {String|ArrayOfStrings} input - Cound be a string to specify the max\n *   level, or an array of exact levels\n * @return {Array} -\n */\n\nLog.parseLevels = function (input) {\n  switch (typeof input) {\n    case 'string':\n      var i = _.indexOf(Log.levels, input);\n\n      if (i >= 0) {\n        return Log.levels.slice(0, i + 1);\n      }\n\n    /* fall through */\n\n    case 'object':\n      if (_.isArray(input)) {\n        var valid = _.intersection(input, Log.levels);\n\n        if (valid.length === input.length) {\n          return valid;\n        }\n      }\n\n    /* fall through */\n\n    default:\n      throw new TypeError('invalid logging level ' + input + '. Expected zero or more of these options: ' + Log.levels.join(', '));\n  }\n};\n/**\n * Combine the array-like param into a simple string\n *\n * @method join\n * @static\n * @private\n * @param  {*} arrayish - An array like object that can be itterated by _.each\n * @return {String} - The final string.\n */\n\n\nLog.join = function (arrayish) {\n  return _.map(arrayish, function (item) {\n    if (_.isPlainObject(item)) {\n      return JSON.stringify(item, null, 2) + '\\n';\n    } else {\n      return item.toString();\n    }\n  }).join(' ');\n};\n/**\n * Create a new logger, based on the config.\n *\n * @method addOutput\n * @param {object} config - An object with config options for the logger.\n * @param {String} [config.type=stdio] - The name of an output/logger. Options\n *   can be found in the `src/loggers` directory.\n * @param {String|ArrayOfStrings} [config.level|config.levels=warning] - The levels to output\n *   to this logger, when an array is specified no levels other than the ones\n *   specified will be listened to. When a string is specified, that and all lower\n *   levels will be logged.\n * @return {Logger}\n */\n\n\nLog.prototype.addOutput = function (config) {\n  config = config || {}; // force \"levels\" key\n\n  config.levels = Log.parseLevels(config.levels || config.level || 'warning');\n  delete config.level;\n  var Logger = utils.funcEnum(config, 'type', Log.loggers, process.browser ? 'console' : 'stdio');\n  return new Logger(this, config);\n};\n/**\n * Log an error\n *\n * @method error\n * @param  {Error|String} error  The Error to log\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.error = function (e) {\n  if (this.listenerCount('error')) {\n    return this.emit('error', e instanceof Error ? e : new Error(e));\n  }\n};\n/**\n * Log a warning message\n *\n * @method warning\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.warning = function ()\n/* ...msg */\n{\n  if (this.listenerCount('warning')) {\n    return this.emit('warning', Log.join(arguments));\n  }\n};\n/**\n * Log useful info about what's going on\n *\n * @method info\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.info = function ()\n/* ...msg */\n{\n  if (this.listenerCount('info')) {\n    return this.emit('info', Log.join(arguments));\n  }\n};\n/**\n * Log a debug level message\n *\n * @method debug\n * @param  {*} msg* - Any amount of messages that will be joined before logged\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.debug = function ()\n/* ...msg */\n{\n  if (this.listenerCount('debug')) {\n    return this.emit('debug', Log.join(arguments));\n  }\n};\n/**\n * Log a trace level message\n *\n * @method trace\n * @param {String} method - HTTP request method\n * @param {String|Object} requestUrl - URL requested. If the value is an object,\n *   it is expected to be the return value of Node's url.parse()\n * @param {String} body - The request's body\n * @param {String} responseBody - body returned from ES\n * @param {String} responseStatus - HTTP status code\n * @return {Boolean} - True if any outputs accepted the message\n */\n\n\nLog.prototype.trace = function (method, requestUrl, body, responseBody, responseStatus) {\n  if (this.listenerCount('trace')) {\n    return this.emit('trace', Log.normalizeTraceArgs(method, requestUrl, body, responseBody, responseStatus));\n  }\n};\n\nLog.normalizeTraceArgs = function (method, requestUrl, body, responseBody, responseStatus) {\n  if (typeof requestUrl === 'string') {\n    requestUrl = url.parse(requestUrl, true, true);\n  } else {\n    requestUrl = _.clone(requestUrl);\n\n    if (requestUrl.path) {\n      requestUrl.query = url.parse(requestUrl.path, true, false).query;\n    }\n\n    if (!requestUrl.pathname && requestUrl.path) {\n      requestUrl.pathname = requestUrl.path.split('?').shift();\n    }\n  }\n\n  delete requestUrl.auth;\n  return {\n    method: method,\n    url: url.format(requestUrl),\n    body: body,\n    status: responseStatus,\n    response: responseBody\n  };\n};\n\nmodule.exports = Log;","map":null,"metadata":{},"sourceType":"script"}