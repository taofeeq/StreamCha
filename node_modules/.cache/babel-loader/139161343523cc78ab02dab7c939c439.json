{"ast":null,"code":"/**\n * Class that manages making request, called by all of the API methods.\n * @type {[type]}\n */\nmodule.exports = Transport;\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar errors = require('./errors');\n\nvar Host = require('./host');\n\nvar patchSniffOnConnectionFault = require('./transport/sniff_on_connection_fault');\n\nvar findCommonProtocol = require('./transport/find_common_protocol');\n\nfunction Transport(config) {\n  var self = this;\n  config = self._config = config || {};\n  var LogClass = typeof config.log === 'function' ? config.log : require('./log');\n  config.log = self.log = new LogClass(config); // setup the connection pool\n\n  var ConnectionPool = utils.funcEnum(config, 'connectionPool', Transport.connectionPools, 'main');\n  self.connectionPool = new ConnectionPool(config); // setup the serializer\n\n  var Serializer = utils.funcEnum(config, 'serializer', Transport.serializers, 'json');\n  self.serializer = new Serializer(config); // setup the nodesToHostCallback\n\n  self.nodesToHostCallback = utils.funcEnum(config, 'nodesToHostCallback', Transport.nodesToHostCallbacks, 'main'); // setup max retries\n\n  self.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : 3; // setup endpoint to use for sniffing\n\n  self.sniffEndpoint = config.hasOwnProperty('sniffEndpoint') ? config.sniffEndpoint : '/_nodes/_all/http'; // setup requestTimeout default\n\n  self.requestTimeout = config.hasOwnProperty('requestTimeout') ? config.requestTimeout : 30000;\n  self.pingTimeout = config.hasOwnProperty('pingTimeout') ? config.pingTimeout : 3000;\n\n  if (config.hasOwnProperty('defer')) {\n    self.defer = config.defer;\n  } // randomizeHosts option\n\n\n  var randomizeHosts = config.hasOwnProperty('randomizeHosts') ? !!config.randomizeHosts : true;\n\n  if (config.host) {\n    config.hosts = config.host;\n  }\n\n  if (config.hosts) {\n    var hostsConfig = utils.createArray(config.hosts, function (val) {\n      if (_.isPlainObject(val) || _.isString(val) || val instanceof Host) {\n        return val;\n      }\n    });\n\n    if (!hostsConfig) {\n      throw new TypeError('Invalid hosts config. Expected a URL, an array of urls, a host config object, ' + 'or an array of host config objects.');\n    }\n\n    if (randomizeHosts) {\n      hostsConfig = _.shuffle(hostsConfig);\n    }\n\n    self.setHosts(hostsConfig);\n  }\n\n  if (config.hasOwnProperty('sniffedNodesProtocol')) {\n    self.sniffedNodesProtocol = config.sniffedNodesProtocol || null;\n  } else {\n    self.sniffedNodesProtocol = findCommonProtocol(self.connectionPool.getAllHosts()) || null;\n  }\n\n  if (config.hasOwnProperty('sniffedNodesFilterPath')) {\n    self.sniffedNodesFilterPath = config.sniffedNodesFilterPath;\n  } else {\n    self.sniffedNodesFilterPath = ['nodes.*.http.publish_address', 'nodes.*.name', 'nodes.*.hostname', 'nodes.*.host', 'nodes.*.version'].join(',');\n  }\n\n  if (config.sniffOnStart) {\n    self.sniff();\n  }\n\n  if (config.sniffInterval) {\n    self._timeout(function doSniff() {\n      self.sniff();\n\n      self._timeout(doSniff, config.sniffInterval);\n    }, config.sniffInterval);\n  }\n\n  if (config.sniffOnConnectionFault) {\n    patchSniffOnConnectionFault(self);\n  }\n}\n\nTransport.connectionPools = {\n  main: require('./connection_pool')\n};\nTransport.serializers = require('./serializers');\nTransport.nodesToHostCallbacks = {\n  main: require('./nodes_to_host')\n};\n\nTransport.prototype.defer = function () {\n  if (typeof Promise === 'undefined') {\n    throw new Error('No Promise implementation found. In order for elasticsearch-js to create promises ' + 'either specify the `defer` configuration or include a global Promise shim');\n  }\n\n  var defer = {};\n  defer.promise = new Promise(function (resolve, reject) {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  return defer;\n};\n/**\n * Perform a request with the client's transport\n *\n * @method request\n * @todo async body writing\n * @todo abort\n * @todo access to custom headers, modifying of request in general\n * @param {object} params\n * @param {Number} params.requestTimeout - timeout for the entire request (inculding all retries)\n * @param {Number} params.maxRetries - number of times to re-run request if the\n *   original node chosen can not be connected to.\n * @param {string} [params.path=\"/\"] - URL pathname. Do not include query string.\n * @param {string|object} [params.query] - Query string.\n * @param {String} params.method - The HTTP method for the request\n * @param {String} params.body - The body of the HTTP request\n * @param {Function} cb - A function to call back with (error, responseBody, responseStatus)\n */\n\n\nTransport.prototype.request = function (params, cb) {\n  var self = this;\n  var remainingRetries = this.maxRetries;\n  var requestTimeout = this.requestTimeout;\n  var connection; // set in sendReqWithConnection\n\n  var aborted = false; // several connector will respond with an error when the request is aborted\n\n  var requestAborter; // an abort function, returned by connection#request()\n\n  var requestTimeoutId; // the id of the ^timeout\n\n  var ret; // the object returned to the user, might be a promise\n\n  var defer; // the defer object, will be set when we are using promises.\n\n  var body = params.body;\n  var headers = !params.headers ? {} : _.transform(params.headers, function (headers, val, name) {\n    headers[String(name).toLowerCase()] = val;\n  });\n  self.log.debug('starting request', params); // determine the response based on the presense of a callback\n\n  if (typeof cb === 'function') {\n    // handle callbacks within a domain\n    if (process.domain) {\n      cb = process.domain.bind(cb);\n    }\n\n    ret = {\n      abort: abortRequest\n    };\n  } else {\n    defer = this.defer();\n    ret = defer.promise;\n    ret.abort = abortRequest;\n  }\n\n  if (body && params.method === 'GET') {\n    utils.nextTick(respond, new TypeError('Body can not be sent with method \"GET\"'));\n    return ret;\n  } // serialize the body\n\n\n  if (body) {\n    var serializer = self.serializer;\n    var serializeFn = serializer[params.bulkBody ? 'bulkBody' : 'serialize'];\n    body = serializeFn.call(serializer, body);\n\n    if (!headers['content-type']) {\n      headers['content-type'] = serializeFn.contentType;\n    }\n  }\n\n  if (params.hasOwnProperty('maxRetries')) {\n    remainingRetries = params.maxRetries;\n  }\n\n  if (params.hasOwnProperty('requestTimeout')) {\n    requestTimeout = params.requestTimeout;\n  }\n\n  var pingRequest = params.path === '/' && params.method === 'HEAD';\n\n  if (pingRequest) {\n    var requestParam = params.hasOwnProperty('requestTimeout') && params.requestTimeout;\n    requestTimeout = requestParam || this.pingTimeout;\n  }\n\n  params.req = {\n    method: params.method,\n    path: params.path || '/',\n    query: params.query,\n    body: body,\n    headers: headers\n  };\n\n  function sendReqWithConnection(err, _connection) {\n    if (aborted) {\n      return;\n    }\n\n    if (err) {\n      respond(err);\n    } else if (_connection) {\n      connection = _connection;\n      requestAborter = connection.request(params.req, checkRespForFailure);\n    } else {\n      self.log.warning('No living connections');\n      respond(new errors.NoConnections());\n    }\n  }\n\n  function checkRespForFailure(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    requestAborter = void 0;\n\n    if (err instanceof errors.RequestTypeError) {\n      self.log.error('Connection refused to execute the request', err);\n      respond(err, body, status, headers);\n      return;\n    }\n\n    if (err) {\n      connection.setStatus('dead');\n      var errMsg = err.message || '';\n      errMsg = '\\n' + params.req.method + ' ' + connection.host.makeUrl(params.req) + (errMsg.length ? ' => ' : '') + errMsg;\n\n      if (remainingRetries) {\n        remainingRetries--;\n        self.log.error('Request error, retrying' + errMsg);\n        self.connectionPool.select(sendReqWithConnection);\n      } else {\n        self.log.error('Request complete with error' + errMsg);\n        respond(new errors.ConnectionFault(err));\n      }\n    } else {\n      self.log.debug('Request complete');\n      respond(void 0, body, status, headers);\n    }\n  }\n\n  function respond(err, body, status, headers) {\n    if (aborted) {\n      return;\n    }\n\n    self._timeout(requestTimeoutId);\n\n    var parsedBody;\n    var isJson = !headers || headers['content-type'] && ~headers['content-type'].indexOf('application/json');\n\n    if (!err && body) {\n      if (isJson) {\n        parsedBody = self.serializer.deserialize(body);\n\n        if (parsedBody == null) {\n          err = new errors.Serialization();\n          parsedBody = body;\n        }\n      } else {\n        parsedBody = body;\n      }\n    } // does the response represent an error?\n\n\n    if ((!err || err instanceof errors.Serialization) && (status < 200 || status >= 300) && (!params.ignore || !_.includes(params.ignore, status))) {\n      var errorMetadata = _.pick(params.req, ['path', 'query', 'body']);\n\n      errorMetadata.statusCode = status;\n      errorMetadata.response = body;\n\n      if (status === 401 && headers && headers['www-authenticate']) {\n        errorMetadata.wwwAuthenticateDirective = headers['www-authenticate'];\n      }\n\n      if (errors[status]) {\n        err = new errors[status](parsedBody && parsedBody.error, errorMetadata);\n      } else {\n        err = new errors.Generic('unknown error', errorMetadata);\n      }\n    } // can we cast notfound to false?\n\n\n    if (params.castExists) {\n      if (err && err instanceof errors.NotFound) {\n        parsedBody = false;\n        err = void 0;\n      } else {\n        parsedBody = !err;\n      }\n    } // how do we send the response?\n\n\n    if (typeof cb === 'function') {\n      if (err) {\n        cb(err, parsedBody, status);\n      } else {\n        cb(void 0, parsedBody, status);\n      }\n    } else if (err) {\n      err.body = parsedBody;\n      err.status = status;\n      defer.reject(err);\n    } else {\n      defer.resolve(parsedBody);\n    }\n  }\n\n  function abortRequest() {\n    if (aborted) {\n      return;\n    }\n\n    aborted = true;\n    remainingRetries = 0;\n\n    self._timeout(requestTimeoutId);\n\n    if (typeof requestAborter === 'function') {\n      requestAborter();\n    }\n  }\n\n  if (requestTimeout && requestTimeout !== Infinity) {\n    requestTimeoutId = this._timeout(function () {\n      respond(new errors.RequestTimeout('Request Timeout after ' + requestTimeout + 'ms'));\n      abortRequest();\n    }, requestTimeout);\n  }\n\n  if (connection) {\n    sendReqWithConnection(void 0, connection);\n  } else {\n    self.connectionPool.select(sendReqWithConnection);\n  }\n\n  return ret;\n};\n\nTransport.prototype._timeout = function (cb, delay) {\n  if (this.closed) return;\n  var id;\n  var timers = this._timers || (this._timers = []);\n\n  if (typeof cb !== 'function') {\n    id = cb;\n    cb = void 0;\n  }\n\n  if (cb) {\n    // set the timer\n    id = setTimeout(function () {\n      _.pull(timers, id);\n\n      cb();\n    }, delay);\n    timers.push(id);\n    return id;\n  }\n\n  if (id) {\n    clearTimeout(id);\n\n    var i = this._timers.indexOf(id);\n\n    if (i !== -1) {\n      this._timers.splice(i, 1);\n    }\n  }\n};\n/**\n * Ask an ES node for a list of all the nodes, add/remove nodes from the connection\n * pool as appropriate\n *\n * @param  {Function} cb - Function to call back once complete\n */\n\n\nTransport.prototype.sniff = function (cb) {\n  var self = this;\n  var nodesToHostCallback = this.nodesToHostCallback;\n  var log = this.log;\n  var sniffedNodesProtocol = this.sniffedNodesProtocol;\n  var sniffedNodesFilterPath = this.sniffedNodesFilterPath; // make cb a function if it isn't\n\n  cb = typeof cb === 'function' ? cb : _.noop;\n  this.request({\n    path: this.sniffEndpoint,\n    query: {\n      filter_path: sniffedNodesFilterPath\n    },\n    method: 'GET'\n  }, function (err, resp, status) {\n    if (!err && resp && resp.nodes) {\n      var hostsConfigs;\n\n      try {\n        hostsConfigs = nodesToHostCallback(resp.nodes);\n      } catch (e) {\n        log.error(new Error('Unable to convert node list from ' + self.sniffEndpoint + ' to hosts durring sniff. Encountered error:\\n' + (e.stack || e.message)));\n        return;\n      }\n\n      _.forEach(hostsConfigs, function (hostConfig) {\n        if (sniffedNodesProtocol) hostConfig.protocol = sniffedNodesProtocol;\n      });\n\n      self.setHosts(hostsConfigs);\n    }\n\n    cb(err, resp, status);\n  });\n};\n/**\n * Set the host list that the transport should use.\n *\n * @param {Array<HostConfig>} hostsConfigs - an array of Hosts, or configuration objects\n *                                         that will be used to create Host objects.\n */\n\n\nTransport.prototype.setHosts = function (hostsConfigs) {\n  var globalConfig = this._config;\n  this.connectionPool.setHosts(_.map(hostsConfigs, function (conf) {\n    return conf instanceof Host ? conf : new Host(conf, globalConfig);\n  }));\n};\n/**\n * Close the Transport, which closes the logs and connection pool\n * @return {[type]} [description]\n */\n\n\nTransport.prototype.close = function () {\n  this.log.close();\n  this.closed = true;\n\n  _.each(this._timers, clearTimeout);\n\n  this._timers = null;\n  this.connectionPool.close();\n};","map":null,"metadata":{},"sourceType":"script"}