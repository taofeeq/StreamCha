{"ast":null,"code":"var utils = require('../utils');\n/**\n * Patch the transport's connection pool to schedule a sniff after a connection fails.\n * When a connection fails for the first time it will schedule a sniff 1 second in the\n * future, and increase the timeout based on the deadTimeout algorithm chosen by the\n * connectionPool, and the number of times the sniff has failed.\n *\n * @param  {Transport} transport - the transport that will be using this behavior\n * @return {undefined}\n */\n\n\nmodule.exports = function setupSniffOnConnectionFault(transport) {\n  var failures = 0;\n  var pool = transport.connectionPool;\n  var originalOnDied = pool._onConnectionDied; // do the actual sniff, if the sniff is unable to\n  // connect to a node this function will be called again by the connectionPool\n\n  var work = function work() {\n    work.timerId = transport._timeout(work.timerId);\n    transport.sniff();\n  }; // create a function that will count down to a\n  // point n milliseconds into the future\n\n\n  var countdownTo = function countdownTo(ms) {\n    var start = utils.now();\n    return function () {\n      return start - ms;\n    };\n  }; // overwrite the function, but still call it\n\n\n  pool._onConnectionDied = function (connection, wasAlreadyDead) {\n    var ret = originalOnDied.call(pool, connection, wasAlreadyDead); // clear the failures if this is the first failure we have seen\n\n    failures = work.timerId ? failures + 1 : 0;\n    var ms = pool.calcDeadTimeout(failures, 1000);\n\n    if (work.timerId && ms < work.timerId && work.countdown()) {\n      // clear the timer\n      work.timerId = transport._timeout(work.timerId);\n    }\n\n    if (!work.timerId) {\n      work.timerId = transport._timeout(work, ms);\n      work.countdown = countdownTo(ms);\n    }\n\n    return ret;\n  };\n\n  pool._onConnectionDied.restore = function () {\n    pool._onConnectionDied = originalOnDied;\n  };\n};","map":null,"metadata":{},"sourceType":"script"}