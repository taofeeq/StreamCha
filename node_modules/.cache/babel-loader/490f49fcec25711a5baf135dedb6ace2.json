{"ast":null,"code":"var _ = require('lodash');\n\nvar utils = require('./utils');\n/**\n * Abstract class providing common functionality to loggers\n * @param {[type]} log [description]\n * @param {[type]} config [description]\n */\n\n\nfunction LoggerAbstract(log, config) {\n  this.log = log;\n  this.listeningLevels = [];\n  utils.makeBoundMethods(this); // when the log closes, remove our event listeners\n\n  this.log.once('closing', this.bound.cleanUpListeners);\n  this.setupListeners(config.levels);\n}\n\nfunction padNumToTen(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n/**\n * Create a timestamp string used in the format function. Defers to Log.timestamp if it is defined,\n * Also, feel free to override this at the logger level.\n * @return {String} - Timestamp in ISO 8601 UTC\n */\n\n\nLoggerAbstract.prototype.timestamp = function () {\n  var d = new Date();\n  return d.getUTCFullYear() + '-' + padNumToTen(d.getUTCMonth() + 1) + '-' + padNumToTen(d.getUTCDate()) + 'T' + padNumToTen(d.getUTCHours()) + ':' + padNumToTen(d.getUTCMinutes()) + ':' + padNumToTen(d.getUTCSeconds()) + 'Z';\n};\n\nfunction indent(text, spaces) {\n  var space = utils.repeat(' ', spaces || 2);\n  return (text || '').split(/\\r?\\n/).map(function (line) {\n    return space + line;\n  }).join('\\n');\n}\n\nLoggerAbstract.prototype.format = function (label, message) {\n  return label + ': ' + this.timestamp() + '\\n' + indent(message) + '\\n\\n';\n};\n\nLoggerAbstract.prototype.write = function () {\n  throw new Error('This should be overwritten by the logger');\n};\n/**\n * Clear the current event listeners and then re-listen for events based on the level specified\n *\n * @method setupListeners\n * @private\n * @param  {Integer} level - The max log level that this logger should listen to\n * @return {undefined}\n */\n\n\nLoggerAbstract.prototype.setupListeners = function (levels) {\n  this.cleanUpListeners();\n  this.listeningLevels = [];\n\n  _.each(levels, _.bind(function (level) {\n    var fnName = 'on' + utils.ucfirst(level);\n\n    if (this.bound[fnName]) {\n      this.listeningLevels.push(level);\n      this.log.on(level, this.bound[fnName]);\n    } else {\n      throw new Error('Unable to listen for level \"' + level + '\"');\n    }\n  }, this));\n};\n/**\n * Clear the current event listeners\n *\n * @method cleanUpListeners\n * @private\n * @return {undefined}\n */\n\n\nLoggerAbstract.prototype.cleanUpListeners = utils.handler(function () {\n  _.each(this.listeningLevels, _.bind(function (level) {\n    this.log.removeListener(level, this.bound['on' + utils.ucfirst(level)]);\n  }, this));\n});\n/**\n * Handler for the logs \"error\" event\n *\n * @method onError\n * @private\n * @param  {Error} e - The Error object to log\n * @return {undefined}\n */\n\nLoggerAbstract.prototype.onError = utils.handler(function (e) {\n  this.write(e.name === 'Error' ? 'ERROR' : e.name, e.stack);\n});\n/**\n * Handler for the logs \"warning\" event\n *\n * @method onWarning\n * @private\n * @param  {String} msg - The message to be logged\n * @return {undefined}\n */\n\nLoggerAbstract.prototype.onWarning = utils.handler(function (msg) {\n  this.write('WARNING', msg);\n});\n/**\n * Handler for the logs \"info\" event\n *\n * @method onInfo\n * @private\n * @param  {String} msg - The message to be logged\n * @return {undefined}\n */\n\nLoggerAbstract.prototype.onInfo = utils.handler(function (msg) {\n  this.write('INFO', msg);\n});\n/**\n * Handler for the logs \"debug\" event\n *\n * @method onDebug\n * @private\n * @param  {String} msg - The message to be logged\n * @return {undefined}\n */\n\nLoggerAbstract.prototype.onDebug = utils.handler(function (msg) {\n  this.write('DEBUG', msg);\n});\n/**\n * Handler for the logs \"trace\" event\n *\n * @method onTrace\n * @private\n * @param  {String} msg - The message to be logged\n * @return {undefined}\n */\n\nLoggerAbstract.prototype.onTrace = utils.handler(function (requestDetails) {\n  this.write('TRACE', this._formatTraceMessage(requestDetails));\n});\n\nLoggerAbstract.prototype._formatTraceMessage = function (req) {\n  return '-> ' + req.method + ' ' + req.url + '\\n' + this._prettyJson(req.body) + '\\n' + '<- ' + req.status + '\\n' + this._prettyJson(req.response);\n  /*\n  -> GET https://sldfkjsdlfksjdf:9200/slsdkfjlxckvxhclks?sdlkj=sdlfkje\n  {\n  asdflksjdf\n  }\n  <- 502\n  {\n  sldfksjdlf\n  }\n  */\n};\n\nLoggerAbstract.prototype._prettyJson = function (body) {\n  try {\n    if (typeof body === 'string') {\n      body = JSON.parse(body);\n    }\n\n    return JSON.stringify(body, null, '  ').replace(/'/g, \"\\\\u0027\");\n  } catch (e) {\n    return typeof body === 'string' ? body : '';\n  }\n};\n\nmodule.exports = LoggerAbstract;","map":null,"metadata":{},"sourceType":"script"}