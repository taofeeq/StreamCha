{"ast":null,"code":"var _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar errors = module.exports;\nvar canCapture = typeof Error.captureStackTrace === 'function';\nvar canStack = !!new Error().stack;\n\nfunction ErrorAbstract(msg, constructor, metadata) {\n  this.message = msg;\n  Error.call(this, this.message);\n\n  if (canCapture) {\n    Error.captureStackTrace(this, constructor);\n  } else if (canStack) {\n    this.stack = new Error().stack;\n  } else {\n    this.stack = '';\n  }\n\n  if (metadata) {\n    _.assign(this, metadata);\n\n    this.toString = function () {\n      return msg + ' :: ' + JSON.stringify(metadata);\n    };\n\n    this.toJSON = function () {\n      return _.assign({\n        msg: msg\n      }, metadata);\n    };\n  }\n}\n\nerrors._Abstract = ErrorAbstract;\nutils.inherits(ErrorAbstract, Error);\n/**\n * Connection Error\n * @param {String} [msg] - An error message that will probably end up in a log.\n */\n\nerrors.ConnectionFault = function ConnectionFault(msg) {\n  ErrorAbstract.call(this, msg || 'Connection Failure', errors.ConnectionFault);\n};\n\nutils.inherits(errors.ConnectionFault, ErrorAbstract);\n/**\n * No Living Connections\n * @param {String} [msg] - An error message that will probably end up in a log.\n */\n\nerrors.NoConnections = function NoConnections(msg) {\n  ErrorAbstract.call(this, msg || 'No Living connections', errors.NoConnections);\n};\n\nutils.inherits(errors.NoConnections, ErrorAbstract);\n/**\n * Generic Error\n * @param {String} [msg] - An error message that will probably end up in a log.\n */\n\nerrors.Generic = function Generic(msg, metadata) {\n  ErrorAbstract.call(this, msg || 'Generic Error', errors.Generic, metadata);\n};\n\nutils.inherits(errors.Generic, ErrorAbstract);\n/**\n * Request Timeout Error\n * @param {String} [msg] - An error message that will probably end up in a log.\n */\n\nerrors.RequestTimeout = function RequestTimeout(msg) {\n  ErrorAbstract.call(this, msg || 'Request Timeout', errors.RequestTimeout);\n};\n\nutils.inherits(errors.RequestTimeout, ErrorAbstract);\n/**\n * Request Body could not be parsed\n * @param {String} [msg] - An error message that will probably end up in a log.\n */\n\nerrors.Serialization = function Serialization(msg) {\n  ErrorAbstract.call(this, msg || 'Unable to parse/serialize body', errors.Serialization);\n};\n\nutils.inherits(errors.Serialization, ErrorAbstract);\n/**\n * Thrown when a browser compatability issue is detected (cough, IE, cough)\n */\n\nerrors.RequestTypeError = function RequestTypeError(feature) {\n  ErrorAbstract.call(this, 'Cross-domain AJAX requests ' + feature + ' are not supported', errors.RequestTypeError);\n};\n\nutils.inherits(errors.RequestTypeError, ErrorAbstract);\nvar statusCodes = [[300, 'Multiple Choices'], [301, 'Moved Permanently'], [302, 'Found'], [303, 'See Other'], [304, 'Not Modified'], [305, 'Use Proxy'], [307, 'Temporary Redirect'], [308, 'Permanent Redirect'], [400, 'Bad Request'], [401, 'Authentication Exception'], [402, 'Payment Required'], [403, ['Authorization Exception', 'Forbidden']], [404, 'Not Found'], [405, 'Method Not Allowed'], [406, 'Not Acceptable'], [407, 'Proxy Authentication Required'], [408, 'Request Timeout'], [409, 'Conflict'], [410, 'Gone'], [411, 'Length Required'], [412, 'Precondition Failed'], [413, 'Request Entity Too Large'], [414, 'Request URIToo Long'], [415, 'Unsupported Media Type'], [416, 'Requested Range Not Satisfiable'], [417, 'Expectation Failed'], [418, 'Im ATeapot'], [421, 'Too Many Connections From This IP'], [426, 'Upgrade Required'], [429, 'Too Many Requests'], [450, 'Blocked By Windows Parental Controls'], [494, 'Request Header Too Large'], [497, 'HTTPTo HTTPS'], [499, 'Client Closed Request'], [500, 'Internal Server Error'], [501, 'Not Implemented'], [502, 'Bad Gateway'], [503, 'Service Unavailable'], [504, 'Gateway Timeout'], [505, 'HTTPVersion Not Supported'], [506, 'Variant Also Negotiates'], [510, 'Not Extended']];\n\n_.each(statusCodes, function createStatusCodeError(tuple) {\n  var status = tuple[0];\n  var names = tuple[1];\n  var allNames = [].concat(names, status);\n  var primaryName = allNames[0];\n  var className = utils.studlyCase(primaryName);\n  allNames = _.uniq(allNames.concat(className));\n\n  function StatusCodeError(msg, metadata) {\n    this.status = status;\n    this.displayName = className;\n    var esErrObject = null;\n\n    if (_.isPlainObject(msg)) {\n      esErrObject = msg;\n      msg = null;\n    }\n\n    if (!esErrObject) {\n      // errors from es now come in two forms, an error string < 2.0 and\n      // an object >= 2.0\n      // TODO: remove after dropping support for < 2.0\n      ErrorAbstract.call(this, msg || primaryName, StatusCodeError, metadata);\n      return this;\n    }\n\n    msg = [].concat(esErrObject.root_cause || []).reduce(function (memo, cause) {\n      if (memo) memo += ' (and) ';\n      memo += '[' + cause.type + '] ' + cause.reason;\n\n      var extraData = _.omit(cause, ['type', 'reason']);\n\n      if (_.size(extraData)) {\n        memo += ', with ' + prettyPrint(extraData);\n      }\n\n      return memo;\n    }, '');\n\n    if (!msg) {\n      if (esErrObject.type) msg += '[' + esErrObject.type + '] ';\n      if (esErrObject.reason) msg += esErrObject.reason;\n    }\n\n    ErrorAbstract.call(this, msg || primaryName, StatusCodeError, metadata);\n    return this;\n  }\n\n  utils.inherits(StatusCodeError, ErrorAbstract);\n  allNames.forEach(function (name) {\n    errors[name] = StatusCodeError;\n  });\n});\n\nfunction prettyPrint(data) {\n  var path = [];\n  return function print(v) {\n    if (typeof v === 'object') {\n      if (path.indexOf(v) > -1) return '[circular]';\n      path.push(v);\n\n      try {\n        return '{ ' + _.map(v, function (subv, name) {\n          return name + '=' + print(subv);\n        }).join(' & ') + ' }';\n      } finally {\n        path.pop();\n      }\n    } else {\n      return JSON.stringify(v);\n    }\n  }(data);\n}","map":null,"metadata":{},"sourceType":"script"}