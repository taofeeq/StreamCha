{"ast":null,"code":"var _ = require('lodash');\n\nvar utils = require('./utils');\n/**\n * Constructs a client action factory that uses specific defaults\n * @type {Function}\n */\n\n\nexports.makeFactoryWithModifier = makeFactoryWithModifier;\n/**\n * Constructs a function that can be called to make a request to ES\n * @type {Function}\n */\n\nexports.factory = makeFactoryWithModifier();\n/**\n * Constructs a proxy to another api method\n * @type {Function}\n */\n\nexports.proxyFactory = exports.factory.proxy; // export so that we can test this\n\nexports._resolveUrl = resolveUrl;\n\nexports.ApiNamespace = function () {};\n\nexports.namespaceFactory = function () {\n  function ClientNamespace(transport, client) {\n    this.transport = transport;\n    this.client = client;\n  }\n\n  ClientNamespace.prototype = new exports.ApiNamespace();\n  return ClientNamespace;\n};\n\nfunction makeFactoryWithModifier(modifier) {\n  modifier = modifier || _.identity;\n\n  var factory = function factory(spec) {\n    spec = modifier(spec);\n\n    if (!_.isPlainObject(spec.params)) {\n      spec.params = {};\n    }\n\n    if (!spec.method) {\n      spec.method = 'GET';\n    }\n\n    function action(params, cb) {\n      if (typeof params === 'function') {\n        cb = params;\n        params = {};\n      } else {\n        params = params || {};\n        cb = typeof cb === 'function' ? cb : null;\n      }\n\n      try {\n        return exec(this.transport, spec, _.clone(params), cb);\n      } catch (e) {\n        if (typeof cb === 'function') {\n          utils.nextTick(cb, e);\n        } else {\n          var def = this.transport.defer();\n          def.reject(e);\n          return def.promise;\n        }\n      }\n    }\n\n    action.spec = spec;\n    return action;\n  };\n\n  factory.proxy = function (fn, spec) {\n    return function (params, cb) {\n      if (typeof params === 'function') {\n        cb = params;\n        params = {};\n      } else {\n        params = params || {};\n        cb = typeof cb === 'function' ? cb : null;\n      }\n\n      if (spec.transform) {\n        spec.transform(params);\n      }\n\n      return fn.call(this, params, cb);\n    };\n  };\n\n  return factory;\n}\n\nvar castType = {\n  enum: function validSelection(param, val, name) {\n    if (_.isString(val) && val.indexOf(',') > -1) {\n      val = commaSepList(val);\n    }\n\n    if (_.isArray(val)) {\n      return val.map(function (v) {\n        return validSelection(param, v, name);\n      }).join(',');\n    }\n\n    for (var i = 0; i < param.options.length; i++) {\n      if (param.options[i] === String(val)) {\n        return param.options[i];\n      }\n    }\n\n    throw new TypeError('Invalid ' + name + ': expected ' + (param.options.length > 1 ? 'one of ' + param.options.join(',') : param.options[0]));\n  },\n  duration: function duration(param, val, name) {\n    if (utils.isNumeric(val) || utils.isInterval(val)) {\n      return val;\n    } else {\n      throw new TypeError('Invalid ' + name + ': expected a number or interval ' + '(an integer followed by one of M, w, d, h, m, s, y or ms).');\n    }\n  },\n  list: function list(param, val, name) {\n    switch (typeof val) {\n      case 'number':\n      case 'boolean':\n        return '' + val;\n\n      case 'string':\n        val = commaSepList(val);\n\n      /* falls through */\n\n      case 'object':\n        if (_.isArray(val)) {\n          return val.join(',');\n        }\n\n      /* falls through */\n\n      default:\n        throw new TypeError('Invalid ' + name + ': expected be a comma separated list, array, number or string.');\n    }\n  },\n  boolean: function boolean(param, val) {\n    val = _.isString(val) ? val.toLowerCase() : val;\n    return val === 'no' || val === 'off' ? false : !!val;\n  },\n  number: function number(param, val, name) {\n    if (utils.isNumeric(val)) {\n      return val * 1;\n    } else {\n      throw new TypeError('Invalid ' + name + ': expected a number.');\n    }\n  },\n  string: function string(param, val, name) {\n    switch (typeof val) {\n      case 'number':\n      case 'string':\n        return '' + val;\n\n      default:\n        throw new TypeError('Invalid ' + name + ': expected a string.');\n    }\n  },\n  time: function time(param, val, name) {\n    if (typeof val === 'string') {\n      return val;\n    } else if (utils.isNumeric(val)) {\n      return '' + val;\n    } else if (val instanceof Date) {\n      return '' + val.getTime();\n    } else {\n      throw new TypeError('Invalid ' + name + ': expected some sort of time.');\n    }\n  }\n};\n\nfunction resolveUrl(url, params) {\n  var vars = {};\n  var i;\n  var key;\n\n  if (url.req) {\n    // url has required params\n    if (!url.reqParamKeys) {\n      // create cached key list on demand\n      url.reqParamKeys = _.keys(url.req);\n    }\n\n    for (i = 0; i < url.reqParamKeys.length; i++) {\n      key = url.reqParamKeys[i];\n\n      if (!params.hasOwnProperty(key) || params[key] == null) {\n        // missing a required param\n        return false;\n      } else {\n        // cast of copy required param\n        if (castType[url.req[key].type]) {\n          vars[key] = castType[url.req[key].type](url.req[key], params[key], key);\n        } else {\n          vars[key] = params[key];\n        }\n      }\n    }\n  }\n\n  if (url.opt) {\n    // url has optional params\n    if (!url.optParamKeys) {\n      url.optParamKeys = _.keys(url.opt);\n    }\n\n    for (i = 0; i < url.optParamKeys.length; i++) {\n      key = url.optParamKeys[i];\n\n      if (params[key]) {\n        if (castType[url.opt[key].type] || params[key] == null) {\n          vars[key] = castType[url.opt[key].type](url.opt[key], params[key], key);\n        } else {\n          vars[key] = params[key];\n        }\n      } else {\n        vars[key] = url.opt[key]['default'];\n      }\n    }\n  }\n\n  if (!url.template) {\n    // compile the template on demand\n    url.template = _.template(url.fmt);\n  }\n\n  return url.template(_.transform(vars, function (note, val, name) {\n    // encode each value\n    note[name] = encodeURIComponent(val); // remove it from the params so that it isn't sent to the final request\n\n    delete params[name];\n  }, {}));\n}\n\nfunction exec(transport, spec, params, cb) {\n  var request = {\n    method: spec.method\n  };\n  var query = {};\n  var i; // pass the timeout from the spec\n\n  if (spec.requestTimeout) {\n    request.requestTimeout = spec.requestTimeout;\n  }\n\n  if (!params.body && spec.paramAsBody) {\n    if (typeof spec.paramAsBody === 'object') {\n      params.body = {};\n\n      if (spec.paramAsBody.castToArray) {\n        params.body[spec.paramAsBody.body] = [].concat(params[spec.paramAsBody.param]);\n      } else {\n        params.body[spec.paramAsBody.body] = params[spec.paramAsBody.param];\n      }\n\n      delete params[spec.paramAsBody.param];\n    } else {\n      params.body = params[spec.paramAsBody];\n      delete params[spec.paramAsBody];\n    }\n  } // verify that we have the body if needed\n\n\n  if (spec.needsBody && !params.body) {\n    throw new TypeError('A request body is required.');\n  } // control params\n\n\n  if (spec.bulkBody) {\n    request.bulkBody = true;\n  }\n\n  if (spec.method === 'HEAD') {\n    request.castExists = true;\n  } // pick the url\n\n\n  if (spec.url) {\n    // only one url option\n    request.path = resolveUrl(spec.url, params);\n  } else {\n    for (i = 0; i < spec.urls.length; i++) {\n      request.path = resolveUrl(spec.urls[i], params);\n\n      if (request.path) {\n        break;\n      }\n    }\n  }\n\n  if (!request.path) {\n    // there must have been some mimimun requirements that were not met\n    var minUrl = spec.url || spec.urls[spec.urls.length - 1];\n    throw new TypeError('Unable to build a path with those params. Supply at least ' + _.keys(minUrl.req).join(', '));\n  } // build the query string\n\n\n  if (!spec.paramKeys) {\n    // build a key list on demand\n    spec.paramKeys = _.keys(spec.params);\n    spec.requireParamKeys = _.transform(spec.params, function (req, param, key) {\n      if (param.required) {\n        req.push(key);\n      }\n    }, []);\n  }\n\n  for (var key in params) {\n    if (params.hasOwnProperty(key) && params[key] != null) {\n      switch (key) {\n        case 'body':\n        case 'headers':\n        case 'requestTimeout':\n        case 'maxRetries':\n          request[key] = params[key];\n          break;\n\n        case 'ignore':\n          request.ignore = _.isArray(params[key]) ? params[key] : [params[key]];\n          break;\n\n        case 'method':\n          request.method = utils.toUpperString(params[key]);\n          break;\n\n        default:\n          var paramSpec = spec.params[key];\n\n          if (paramSpec) {\n            // param keys don't always match the param name, in those cases it's stored in the param def as \"name\"\n            paramSpec.name = paramSpec.name || key;\n\n            if (params[key] != null) {\n              if (castType[paramSpec.type]) {\n                query[paramSpec.name] = castType[paramSpec.type](paramSpec, params[key], key);\n              } else {\n                query[paramSpec.name] = params[key];\n              }\n\n              if (paramSpec['default'] && query[paramSpec.name] === paramSpec['default']) {\n                delete query[paramSpec.name];\n              }\n            }\n          } else {\n            query[key] = params[key];\n          }\n\n      }\n    }\n  }\n\n  for (i = 0; i < spec.requireParamKeys.length; i++) {\n    if (!query.hasOwnProperty(spec.requireParamKeys[i])) {\n      throw new TypeError('Missing required parameter ' + spec.requireParamKeys[i]);\n    }\n  }\n\n  request.query = query;\n  return transport.request(request, cb);\n}\n\nfunction commaSepList(str) {\n  return str.split(',').map(function (i) {\n    return i.trim();\n  });\n}","map":null,"metadata":{},"sourceType":"script"}