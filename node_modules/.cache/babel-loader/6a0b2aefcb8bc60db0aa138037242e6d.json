{"ast":null,"code":"/**\n * Manager of connections to a node(s), capable of ensuring that connections are clear and living\n * before providing them to the application\n *\n * @class ConnectionPool\n * @constructor\n * @param {Object} config - The config object passed to the transport.\n */\nmodule.exports = ConnectionPool;\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar Log = require('./log');\n\nfunction ConnectionPool(config) {\n  config = config || {};\n  utils.makeBoundMethods(this);\n\n  if (!config.log) {\n    this.log = new Log();\n    config.log = this.log;\n  } else {\n    this.log = config.log;\n  } // we will need this when we create connections down the road\n\n\n  this._config = config; // get the selector config var\n\n  this.selector = utils.funcEnum(config, 'selector', ConnectionPool.selectors, ConnectionPool.defaultSelector); // get the connection class\n\n  this.Connection = utils.funcEnum(config, 'connectionClass', ConnectionPool.connectionClasses, ConnectionPool.defaultConnectionClass); // time that connections will wait before being revived\n\n  this.deadTimeout = config.hasOwnProperty('deadTimeout') ? config.deadTimeout : 60000;\n  this.maxDeadTimeout = config.hasOwnProperty('maxDeadTimeout') ? config.maxDeadTimeout : 18e5;\n  this.calcDeadTimeout = utils.funcEnum(config, 'calcDeadTimeout', ConnectionPool.calcDeadTimeoutOptions, 'exponential'); // a map of connections to their \"id\" property, used when sniffing\n\n  this.index = {};\n  this._conns = {\n    alive: [],\n    dead: []\n  }; // information about timeouts for dead connections\n\n  this._timeouts = [];\n} // selector options\n\n\nConnectionPool.selectors = require('./selectors');\nConnectionPool.defaultSelector = 'roundRobin'; // get the connection options\n\nConnectionPool.connectionClasses = require('./connectors');\nConnectionPool.defaultConnectionClass = ConnectionPool.connectionClasses._default;\ndelete ConnectionPool.connectionClasses._default; // the function that calculates timeouts based on attempts\n\nConnectionPool.calcDeadTimeoutOptions = {\n  flat: function flat(attempt, baseTimeout) {\n    return baseTimeout;\n  },\n  exponential: function exponential(attempt, baseTimeout) {\n    return Math.min(baseTimeout * 2 * Math.pow(2, attempt * 0.5 - 1), this.maxDeadTimeout);\n  }\n};\n/**\n * Selects a connection from the list using the this.selector\n * Features:\n *  - detects if the selector is async or not\n *  - sync selectors should still return asynchronously\n *  - catches errors in sync selectors\n *  - automatically selects the first dead connection when there no living connections\n *\n * @param  {Function} cb [description]\n * @return {[type]}      [description]\n */\n\nConnectionPool.prototype.select = function (cb) {\n  if (this._conns.alive.length) {\n    if (this.selector.length > 1) {\n      this.selector(this._conns.alive, cb);\n    } else {\n      try {\n        utils.nextTick(cb, void 0, this.selector(this._conns.alive));\n      } catch (e) {\n        cb(e);\n      }\n    }\n  } else if (this._timeouts.length) {\n    this._selectDeadConnection(cb);\n  } else {\n    utils.nextTick(cb, void 0);\n  }\n};\n/**\n * Handler for the \"set status\" event emitted but the connections. It will move\n * the connection to it's proper connection list (unless it was closed).\n *\n * @param  {String} status - the connection's new status\n * @param  {String} oldStatus - the connection's old status\n * @param  {ConnectionAbstract} connection - the connection object itself\n */\n\n\nConnectionPool.prototype.onStatusSet = utils.handler(function (status, oldStatus, connection) {\n  var index;\n  var died = status === 'dead';\n  var wasAlreadyDead = died && oldStatus === 'dead';\n  var revived = !died && oldStatus === 'dead';\n  var noChange = oldStatus === status;\n  var from = this._conns[oldStatus];\n  var to = this._conns[status];\n\n  if (noChange && !died) {\n    return true;\n  }\n\n  if (from !== to) {\n    if (_.isArray(from)) {\n      index = from.indexOf(connection);\n\n      if (index !== -1) {\n        from.splice(index, 1);\n      }\n    }\n\n    if (_.isArray(to)) {\n      index = to.indexOf(connection);\n\n      if (index === -1) {\n        to.push(connection);\n      }\n    }\n  }\n\n  if (died) {\n    this._onConnectionDied(connection, wasAlreadyDead);\n  }\n\n  if (revived) {\n    this._onConnectionRevived(connection);\n  }\n});\n/**\n * Handler used to clear the times created when a connection dies\n * @param  {ConnectionAbstract} connection\n */\n\nConnectionPool.prototype._onConnectionRevived = function (connection) {\n  var timeout;\n\n  for (var i = 0; i < this._timeouts.length; i++) {\n    if (this._timeouts[i].conn === connection) {\n      timeout = this._timeouts[i];\n\n      if (timeout.id) {\n        clearTimeout(timeout.id);\n      }\n\n      this._timeouts.splice(i, 1);\n\n      break;\n    }\n  }\n};\n/**\n * Handler used to update or create a timeout for the connection which has died\n * @param  {ConnectionAbstract} connection\n * @param  {Boolean} alreadyWasDead - If the connection was preivously dead this must be set to true\n */\n\n\nConnectionPool.prototype._onConnectionDied = function (connection, alreadyWasDead) {\n  var timeout;\n\n  if (alreadyWasDead) {\n    for (var i = 0; i < this._timeouts.length; i++) {\n      if (this._timeouts[i].conn === connection) {\n        timeout = this._timeouts[i];\n        break;\n      }\n    }\n  } else {\n    timeout = {\n      conn: connection,\n      attempt: 0,\n      revive: function revive(cb) {\n        timeout.attempt++;\n        connection.ping(function (err) {\n          connection.setStatus(err ? 'dead' : 'alive');\n\n          if (cb && typeof cb === 'function') {\n            cb(err);\n          }\n        });\n      }\n    };\n\n    this._timeouts.push(timeout);\n  }\n\n  if (timeout.id) {\n    clearTimeout(timeout.id);\n  }\n\n  var ms = this.calcDeadTimeout(timeout.attempt, this.deadTimeout);\n  timeout.id = setTimeout(timeout.revive, ms);\n  timeout.runAt = utils.now() + ms;\n};\n\nConnectionPool.prototype._selectDeadConnection = function (cb) {\n  var orderedTimeouts = _.sortBy(this._timeouts, 'runAt');\n\n  var log = this.log;\n  process.nextTick(function next() {\n    var timeout = orderedTimeouts.shift();\n\n    if (!timeout) {\n      cb(void 0);\n      return;\n    }\n\n    if (!timeout.conn) {\n      next();\n      return;\n    }\n\n    if (timeout.conn.status === 'dead') {\n      timeout.revive(function (err) {\n        if (err) {\n          log.warning('Unable to revive connection: ' + timeout.conn.id);\n          process.nextTick(next);\n        } else {\n          cb(void 0, timeout.conn);\n        }\n      });\n    } else {\n      cb(void 0, timeout.conn);\n    }\n  });\n};\n/**\n * Returns a random list of nodes from the living connections up to the limit.\n * If there are no living connections it will fall back to the dead connections.\n * If there are no dead connections it will return nothing.\n *\n * This is used for testing (when we just want the one existing node)\n * and sniffing, where using the selector to get all of the living connections\n * is not reasonable.\n *\n * @param {string} [status] - optional status of the connection to fetch\n * @param {Number} [limit] - optional limit on the number of connections to return\n */\n\n\nConnectionPool.prototype.getConnections = function (status, limit) {\n  var list;\n\n  if (status) {\n    list = this._conns[status];\n  } else {\n    list = this._conns[this._conns.alive.length ? 'alive' : 'dead'];\n  }\n\n  if (limit == null) {\n    return list.slice(0);\n  } else {\n    return _.shuffle(list).slice(0, limit);\n  }\n};\n/**\n * Add a single connection to the pool and change it's status to \"alive\".\n * The connection should inherit from ConnectionAbstract\n *\n * @param {ConnectionAbstract} connection - The connection to add\n */\n\n\nConnectionPool.prototype.addConnection = function (connection) {\n  if (!connection.id) {\n    connection.id = connection.host.toString();\n  }\n\n  if (!this.index[connection.id]) {\n    this.log.info('Adding connection to', connection.id);\n    this.index[connection.id] = connection;\n    connection.on('status set', this.bound.onStatusSet);\n    connection.setStatus('alive');\n  }\n};\n/**\n * Remove a connection from the pool, and set it's status to \"closed\".\n *\n * @param  {ConnectionAbstract} connection - The connection to remove/close\n */\n\n\nConnectionPool.prototype.removeConnection = function (connection) {\n  if (!connection.id) {\n    connection.id = connection.host.toString();\n  }\n\n  if (this.index[connection.id]) {\n    delete this.index[connection.id];\n    connection.setStatus('closed');\n    connection.removeListener('status set', this.bound.onStatusSet);\n  }\n};\n/**\n * Override the internal node list. All connections that are not in the new host\n * list are closed and removed. Non-unique hosts are ignored.\n *\n * @param {Host[]} hosts - An array of Host instances.\n */\n\n\nConnectionPool.prototype.setHosts = function (hosts) {\n  var connection;\n  var i;\n  var id;\n  var host;\n\n  var toRemove = _.clone(this.index);\n\n  for (i = 0; i < hosts.length; i++) {\n    host = hosts[i];\n    id = host.toString();\n\n    if (this.index[id]) {\n      delete toRemove[id];\n    } else {\n      connection = new this.Connection(host, this._config);\n      connection.id = id;\n      this.addConnection(connection);\n    }\n  }\n\n  var removeIds = _.keys(toRemove);\n\n  for (i = 0; i < removeIds.length; i++) {\n    this.removeConnection(this.index[removeIds[i]]);\n  }\n};\n\nConnectionPool.prototype.getAllHosts = function () {\n  return _.values(this.index).map(function (connection) {\n    return connection.host;\n  });\n};\n/**\n * Close the conncetion pool, as well as all of it's connections\n */\n\n\nConnectionPool.prototype.close = function () {\n  this.setHosts([]);\n};\n\nConnectionPool.prototype.empty = ConnectionPool.prototype.close;","map":null,"metadata":{},"sourceType":"script"}