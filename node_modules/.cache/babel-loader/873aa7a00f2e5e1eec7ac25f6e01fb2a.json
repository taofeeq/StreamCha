{"ast":null,"code":"/**\n * Class to wrap URLS, formatting them and maintaining their separate details\n * @type {[type]}\n */\nmodule.exports = Host;\n\nvar url = require('url');\n\nvar qs = require('querystring');\n\nvar _ = require('lodash');\n\nvar utils = require('./utils');\n\nvar startsWithProtocolRE = /^([a-z]+:)?\\/\\//;\nvar defaultProto = 'http:';\nvar btoa;\n\nif (typeof window !== 'undefined' && typeof window.location !== 'undefined') {\n  defaultProto = window.location.protocol;\n  btoa = window.btoa;\n}\n\nbtoa = btoa || function (data) {\n  return new Buffer(data, 'utf8').toString('base64');\n};\n\nvar urlParseFields = ['protocol', 'hostname', 'pathname', 'port', 'auth', 'query'];\nvar simplify = ['host', 'path'];\nvar sslDefaults = {\n  pfx: null,\n  key: null,\n  passphrase: null,\n  cert: null,\n  ca: null,\n  ciphers: null,\n  rejectUnauthorized: false,\n  secureProtocol: null\n}; // simple reference used when formatting as a url\n// and defines when parsing from a string\n\nHost.defaultPorts = {\n  http: 80,\n  https: 443\n};\n\nfunction Host(config, globalConfig) {\n  config = _.clone(config || {});\n  globalConfig = globalConfig || {}; // defaults\n\n  this.protocol = 'http';\n  this.host = 'localhost';\n  this.path = '';\n  this.port = 9200;\n  this.query = null;\n  this.headers = null;\n  this.suggestCompression = !!globalConfig.suggestCompression;\n  this.ssl = _.defaults({}, config.ssl || {}, globalConfig.ssl || {}, sslDefaults);\n\n  if (typeof config === 'string') {\n    var firstColon = config.indexOf(':');\n    var firstSlash = config.indexOf('/');\n    var noSlash = firstSlash === -1;\n    var portNoPath = firstColon > -1 && noSlash;\n    var portWithPath = !portNoPath && firstColon < firstSlash;\n\n    if ((noSlash || portNoPath || portWithPath) && !startsWithProtocolRE.test(config)) {\n      config = defaultProto + '//' + config;\n    }\n\n    config = _.pick(url.parse(config, false, true), urlParseFields); // default logic for the port is to use 9200 for the default. When a string is specified though,\n    // we will use the default from the protocol of the string.\n\n    if (!config.port) {\n      var proto = config.protocol || 'http';\n\n      if (proto.charAt(proto.length - 1) === ':') {\n        proto = proto.substring(0, proto.length - 1);\n      }\n\n      if (Host.defaultPorts[proto]) {\n        config.port = Host.defaultPorts[proto];\n      }\n    }\n  }\n\n  if (_.isObject(config)) {\n    // move hostname/portname to host/port semi-intelligently.\n    _.each(simplify, function (to) {\n      var from = to + 'name';\n\n      if (config[from] && config[to]) {\n        if (config[to].indexOf(config[from]) === 0) {\n          config[to] = config[from];\n        }\n      } else if (config[from]) {\n        config[to] = config[from];\n      }\n\n      delete config[from];\n    });\n  } else {\n    config = {};\n  }\n\n  if (!config.auth && globalConfig.httpAuth) {\n    config.auth = globalConfig.httpAuth;\n  }\n\n  if (config.auth) {\n    config.headers = config.headers || {};\n    config.headers.Authorization = 'Basic ' + btoa(config.auth);\n    delete config.auth;\n  }\n\n  _.forOwn(config, _.bind(function (val, prop) {\n    if (val != null) this[prop] = _.clone(val);\n  }, this)); // make sure the query string is parsed\n\n\n  if (this.query === null) {\n    // majority case\n    this.query = {};\n  } else if (!_.isPlainObject(this.query)) {\n    this.query = qs.parse(this.query);\n  } // make sure that the port is a number\n\n\n  if (utils.isNumeric(this.port)) {\n    this.port = parseInt(this.port, 10);\n  } else {\n    this.port = 9200;\n  } // make sure the path starts with a leading slash\n\n\n  if (this.path === '/') {\n    this.path = '';\n  } else if (this.path && this.path.charAt(0) !== '/') {\n    this.path = '/' + (this.path || '');\n  } // strip trailing ':' on the protocol (when config comes from url.parse)\n\n\n  if (this.protocol.substr(-1) === ':') {\n    this.protocol = this.protocol.substring(0, this.protocol.length - 1);\n  }\n}\n\nHost.prototype.makeUrl = function (params) {\n  params = params || {}; // build the port\n\n  var port = '';\n\n  if (this.port !== Host.defaultPorts[this.protocol]) {\n    // add an actual port\n    port = ':' + this.port;\n  } // build the path\n\n\n  var path = '' + (this.path || '') + (params.path || ''); // if path doesn't start with '/' add it.\n\n  if (path.charAt(0) !== '/') {\n    path = '/' + path;\n  } // build the query string\n\n\n  var query = qs.stringify(this.getQuery(params.query));\n\n  if (this.host) {\n    return this.protocol + '://' + this.host + port + path + (query ? '?' + query : '');\n  } else {\n    return path + (query ? '?' + query : '');\n  }\n};\n\nfunction objectPropertyGetter(prop, preOverride) {\n  return function (overrides) {\n    if (preOverride) {\n      overrides = preOverride.call(this, overrides);\n    }\n\n    var obj = this[prop];\n\n    if (!obj && !overrides) {\n      return null;\n    }\n\n    if (overrides) {\n      obj = _.assign({}, obj, overrides);\n    }\n\n    return _.size(obj) ? obj : null;\n  };\n}\n\nHost.prototype.getHeaders = objectPropertyGetter('headers', function (overrides) {\n  if (!this.suggestCompression) {\n    return overrides;\n  }\n\n  return _.defaults(overrides || {}, {\n    'Accept-Encoding': 'gzip,deflate'\n  });\n});\nHost.prototype.getQuery = objectPropertyGetter('query', function (query) {\n  return typeof query === 'string' ? qs.parse(query) : query;\n});\n\nHost.prototype.toString = function () {\n  return this.makeUrl();\n};","map":null,"metadata":{},"sourceType":"script"}