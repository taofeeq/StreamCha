{"ast":null,"code":"var _ = require('lodash');\n\nvar nodeUtils = require('util');\n/**\n * Custom utils library\n *\n * @class utils\n * @static\n */\n\n\nvar utils = {};\nutils.inherits = nodeUtils.inherits;\n/**\n * Test if a value is an array and its contents are string type\n *\n * @method isArrayOfStrings\n * @param  {Array} arr - An array to check\n * @return {Boolean}\n */\n\nutils.isArrayOfStrings = function (arr) {\n  // quick shallow check of arrays\n  return _.isArray(arr) && _.every(arr.slice(0, 10), _.isString);\n};\n/**\n * Capitalize the first letter of a word\n *\n * @method  ucfirst\n * @param  {string} word - The word to transform\n * @return {string}\n */\n\n\nutils.ucfirst = function (word) {\n  return word[0].toUpperCase() + word.substring(1).toLowerCase();\n};\n/**\n * Base algo for studlyCase and camelCase\n * @param  {boolean} firstWordCap - Should the first character of the first word be capitalized\n * @return {Function}\n */\n\n\nfunction adjustWordCase(firstWordCap, otherWordsCap, sep) {\n  return function (string) {\n    var i = 0;\n    var words = [];\n    var word = '';\n    var code, c, upper, lower;\n\n    for (; i < string.length; i++) {\n      code = string.charCodeAt(i);\n      c = string.charAt(i);\n      lower = code >= 97 && code <= 122 || code >= 48 && code <= 57;\n      upper = code >= 65 && code <= 90;\n\n      if (upper || !lower) {\n        // new word\n        if (word.length) {\n          words.push(word);\n        }\n\n        word = '';\n      }\n\n      if (upper || lower) {\n        if (lower && word.length) {\n          word += c;\n        } else {\n          if (!words.length && firstWordCap || words.length && otherWordsCap) {\n            word = c.toUpperCase();\n          } else {\n            word = c.toLowerCase();\n          }\n        }\n      }\n    }\n\n    if (word.length) {\n      words.push(word);\n    } // add the leading underscore back to strings the had it originally\n\n\n    if (words.length && string.charAt(0) === '_') {\n      words[0] = '_' + words[0];\n    }\n\n    return words.join(sep);\n  };\n}\n/**\n * Transform a string into StudlyCase\n *\n * @method studlyCase\n * @param  {String} string\n * @return {String}\n */\n\n\nutils.studlyCase = adjustWordCase(true, true, '');\n/**\n * Transform a string into camelCase\n *\n * @method camelCase\n * @param  {String} string\n * @return {String}\n */\n\nutils.camelCase = adjustWordCase(false, true, '');\n/**\n * Transform a string into snakeCase\n *\n * @method snakeCase\n * @param  {String} string\n * @return {String}\n */\n\nutils.snakeCase = adjustWordCase(false, false, '_');\n/**\n * Upper-case the string, return an empty string if any is not a string\n *\n * @param any {*} - Something or nothing\n * @returns {string}\n */\n\nutils.toUpperString = function (any) {\n  if (any) {\n    if (typeof any !== 'string') {\n      any = any.toString();\n    }\n  } else {\n    any = '';\n  }\n\n  return any.toUpperCase();\n};\n/**\n * Test if a value is \"numeric\" meaning that it can be transformed into something besides NaN\n *\n * @method isNumeric\n * @param  {*} val\n * @return {Boolean}\n */\n\n\nutils.isNumeric = function (val) {\n  return typeof val !== 'object' && val - parseFloat(val) >= 0;\n}; // regexp to test for intervals\n\n\nvar intervalRE = /^(\\d+(?:\\.\\d+)?)(M|w|d|h|m|s|y|ms)$/;\n/**\n * Test if a string represents an interval (eg. 1m, 2Y)\n *\n * @method isInterval\n * @param {String} val\n * @return {Boolean}\n */\n\nutils.isInterval = function (val) {\n  return !!(val.match && val.match(intervalRE));\n};\n/**\n * Repeat a string n times\n *\n * @todo TestPerformance\n * @method repeat\n * @param {String} what - The string to repeat\n * @param {Number} times - Times the string should be repeated\n * @return {String}\n */\n\n\nutils.repeat = function (what, times) {\n  return new Array(times + 1).join(what);\n};\n/**\n * Call a function, applying the arguments object to it in an optimized way, rather than always turning it into an array\n *\n * @param func {Function} - The function to execute\n * @param context {*} - The context the function will be executed with\n * @param args {Arguments} - The arguments to send to func\n * @param [sliceIndex=0] {Integer} - The index that args should be sliced at, before feeding args to func\n * @returns {*} - the return value of func\n */\n\n\nutils.applyArgs = function (func, context, args, sliceIndex) {\n  sliceIndex = sliceIndex || 0;\n\n  switch (args.length - sliceIndex) {\n    case 0:\n      return func.call(context);\n\n    case 1:\n      return func.call(context, args[0 + sliceIndex]);\n\n    case 2:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex]);\n\n    case 3:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex]);\n\n    case 4:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex]);\n\n    case 5:\n      return func.call(context, args[0 + sliceIndex], args[1 + sliceIndex], args[2 + sliceIndex], args[3 + sliceIndex], args[4 + sliceIndex]);\n\n    default:\n      return func.apply(context, Array.prototype.slice.call(args, sliceIndex));\n  }\n};\n/**\n * Schedule a function to be called on the next tick, and supply it with these arguments\n * when it is called.\n * @return {[type]} [description]\n */\n\n\nutils.nextTick = function (cb) {\n  // bind the function and schedule it\n  process.nextTick(_.bindKey(utils, 'applyArgs', cb, null, arguments, 1));\n};\n/**\n * Marks a method as a handler. Currently this just makes a property on the method\n * flagging it to be bound to the object at object creation when \"makeBoundMethods\" is called\n *\n * ```\n * ClassName.prototype.methodName = utils.handler(function () {\n *   // this will always be bound when called via classInstance.bound.methodName\n *   this === classInstance\n * });\n * ```\n *\n * @param  {Function} func - The method that is being defined\n * @return {Function}\n */\n\n\nutils.handler = function (func) {\n  func._provideBound = true;\n  return func;\n};\n/**\n * Creates an \"bound\" property on an object, which all or a subset of methods from\n * the object which are bound to the original object.\n *\n * ```\n * var obj = {\n *   onEvent: function () {}\n * };\n *\n * utils.makeBoundMethods(obj);\n *\n * obj.bound.onEvent() // is bound to obj, and can safely be used as an event handler.\n * ```\n *\n * @param {Object} obj - The object to bind the methods to\n */\n\n\nutils.makeBoundMethods = function (obj) {\n  obj.bound = {};\n\n  for (var prop in obj) {\n    // dearest maintainer, we want to look through the prototype\n    if (typeof obj[prop] === 'function' && obj[prop]._provideBound === true) {\n      obj.bound[prop] = _.bind(obj[prop], obj);\n    }\n  }\n};\n/**\n * Implements the standard \"string or constructor\" check that I was copy/pasting everywhere\n * @param  {String|Function} val - the value that the user passed in\n * @param  {Object} opts - a map of the options\n * @return {Function|undefined} - If a valid option was specified, then the constructor is returned\n */\n\n\nutils.funcEnum = function (config, name, opts, def) {\n  var val = config[name];\n\n  switch (typeof val) {\n    case 'undefined':\n      return opts[def];\n\n    case 'function':\n      return val;\n\n    case 'string':\n      if (opts.hasOwnProperty(val)) {\n        return opts[val];\n      }\n\n    /* falls through */\n\n    default:\n      var err = 'Invalid ' + name + ' \"' + val + '\", expected a function';\n\n      switch (_.size(opts)) {\n        case 0:\n          break;\n\n        case 1:\n          err += ' or ' + _.keys(opts)[0];\n          break;\n\n        default:\n          err += ' or one of ' + _.keys(opts).join(', ');\n          break;\n      }\n\n      throw new TypeError(err);\n  }\n};\n/**\n * Accepts any object and attempts to convert it into an array. If the object passed in is not\n * an array it will be wrapped in one. Then the transform/map function will be called for each element\n * and create a new array that is returned. If the map function fails to return something, the loop is\n * halted and false is returned instead of an array.\n *\n * @param  {*} input - The value to convert\n * @param  {Function} transform - A function called for each element of the resulting array\n * @return {Array|false} - an array on success, or false on failure.\n */\n\n\nutils.createArray = function (input, transform) {\n  transform = typeof transform === 'function' ? transform : _.identity;\n  var output = [];\n  var item;\n  var i;\n\n  if (!_.isArray(input)) {\n    input = [input];\n  }\n\n  for (i = 0; i < input.length; i++) {\n    item = transform(input[i]);\n\n    if (item === void 0) {\n      return false;\n    } else {\n      output.push(item);\n    }\n  }\n\n  return output;\n};\n/**\n * Takes a WritableStream, and returns the chunks that have not successfully written, returning them as a string.\n *\n * ONLY WORKS FOR TEXT STREAMS\n *\n * @param  {WritableStream} stream - an instance of stream.Writable\n * @return {string} - the remaining test to be written to the stream\n */\n\n\nutils.getUnwrittenFromStream = function (stream) {\n  var writeBuffer = utils.getStreamWriteBuffer(stream);\n  if (!writeBuffer) return; // flush the write buffer\n\n  var out = '';\n  if (!writeBuffer.length) return out;\n\n  _.each(writeBuffer, function (writeReq) {\n    if (writeReq.chunk) {\n      // 0.9.12+ uses WriteReq objects with a chunk prop\n      out += '' + writeReq.chunk;\n    } else if (_.isArray(writeReq) && (typeof writeReq[0] === 'string' || Buffer.isBuffer(writeReq[0]))) {\n      // 0.9.4 - 0.9.9 buffers are arrays of arrays like [[chunk, cb], [chunk, undef], ...].\n      out += '' + writeReq[0];\n    } else {\n      return false;\n    }\n  });\n\n  return out;\n};\n\nutils.getStreamWriteBuffer = function (stream) {\n  if (!stream || !stream._writableState) return;\n  var writeState = stream._writableState;\n\n  if (writeState.getBuffer) {\n    return writeState.getBuffer();\n  } else if (writeState.buffer) {\n    return writeState.buffer;\n  }\n};\n\nutils.clearWriteStreamBuffer = function (stream) {\n  var buffer = utils.getStreamWriteBuffer(stream);\n  return buffer && buffer.splice(0);\n};\n/**\n * return the current time in milliseconds since epoch\n */\n\n\nutils.now = function () {\n  return typeof Date.now === 'function' ? Date.now() : new Date().getTime();\n};\n\nmodule.exports = utils;","map":null,"metadata":{},"sourceType":"script"}